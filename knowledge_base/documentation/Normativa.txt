Manual de Usuario de Teradata - Procesos Airflow CRM 2.0

El siguiente manual de usuario detalla las normas de desarrollo de BTEQs de Teradata de un DAG en los desarrollos de procesos de Airflow CRM 2.0 y Dominio.

Estas indicaciones serán adicionales a las que ya existen en la normativa oficial de Teradata para realizar querys optimizadas. Con el fin de dar énfasis a ciertas recomendaciones del documento de normativa (Gerencia Técnica de Mantención de datos Versión No. 1.2 27/09/2019) es que se han vuelto a incluir en este documento.

# Índice

1. Confección de BTEQs
1. ❌ Organización y Máximo de Líneas de BTEQs
2. ⚠ Nombres de BTEQs
3. ⚠ Encabezado de BTEQ
4. ❌ Sentencias de Inicio y Fin de BTEQ
5. ⚠ Comentarios de Encabezado
6. ⚠ Comentarios de Sentencias
7. ⚠ Creación de Tablas Temporales
1. ❌ Tablas con Prefijo T
2. ❌ Tablas con Prefijo P
8. ❌ Sentencias SELECT
9. ⚠ Indentación
10. Alias
1. ⚠ Alias de Tablas
2. ⚠ Alias de Campos
11. ❌ Campos dentro de GROUP BY
12. ❌ Validación de Resultados
13. ❌ Comprobaciones
14. ❌ Estadísticas
15. ❌ Borrado de Tablas Temporales
16. ❌ Procesos Reprocesables
17. ❌ Procesos Idempotentes
18. ❌ Creación de Tabla Histórica
19. ❌ Creación de Vistas
20. ❌ Prueba de BTEQs
2. Formato de Datos
1. ⚠ RUT de Clientes
2. ❌ Tipo de Campo DATE
3. ❌ Tipo de Campo CHAR o VARCHAR
4. ⚠ Sentencia COMPRESS
5. ❌ Tipo de Datos FLOAT
3. Condiciones, Prohibiciones y Recomendaciones
1. ❌ Fuentes de Datos Productivas




# 3.2. ⚠ SELECT a Vistas de Fuentes de Datos Productivas

# 3.3. ⚠ Filtrado de Fuentes de Datos Productivas

# 3.4. ❌ Manejo de Fechas

# 3.5. ❌ Consultas Anidadas

# 3.6. ❌ Líneas de Código Comentadas

# 3.7. ⚠ Uso de DISTINCT

# 3.8. ❌ Acerca de la Utilización de Tablas SET y MULTISET

# 3.9. Uso de las Cláusulas LEFT, RIGHT, FULL OUTER JOIN

# 3.9.1. ❌ Uso Excesivo

# 3.9.2. ⚠ Orden de JOINS

# 3.9.3. ❌ Cláusula ON

# 3.10. ❌ Cláusula WHERE

# 3.11. ❌ Uso de Comparador ‘&#x3C;>ʼ

# 3.12. ⚠ Comando LIKE

# 3.13. ❌ Comando IN

# 3.14. ⚠ Comando OR

# 3.15. ⚠ Comando EXISTS/NOT EXISTS

# 3.16. ❌ Sentencias CASE

# 3.17. ⚠ Sentencias REPEAT

# 3.18. ❌ Sentencias UPDATE

# 3.19. ❌ Tablas Volátiles

# 3.20. ❌ Procedimientos Almacenados

# 3.21. ⚠ Uso de Particiones en las Tablas

# 3.22. ❌ Acerca del Spool

# Control de Versiones:

| Versión | Fecha      | Autor              | Detalles                                                                                                                  |
| ------- | ---------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| 1.0     | 16-04-2024 | Benjamín Contreras | Se da a conocer Manual de Usuario de Teradata - Procesos Airflow CRM 2.0                                                  |
| 1.1     | 29-07-2025 | Benjamín Contreras | Se realizan modificaciones y adiciones a las reglas. Adicionalmente, se añaden símbolos de errores (❌) y de warnings (⚠). |

Reglas modificadas:

1. 1.1. Organización y Máximo de Líneas de BTEQs
2. 1.2. Nombres de BTEQs
3. 1.3. Encabezado de BTEQ
4. 1.4. Sentencias de Inicio y Fin de BTEQ




# 1.10. Alias de Tablas

# 1.10.2. Alias de Campos

# 1.12. Validación de Resultados

# 1.14. Estadísticas

# 1.18. Creación de Tabla Histórica

# 2.1. RUT de Clientes

# 2.3. Tipo de Campo CHAR o VARCHAR

# 3.7. Uso de DISTINCT

# 3.9.1. Uso Excesivo

# 3.10. Cláusula WHERE

# 3.13. Comando IN

# 3.15. Comando OR

# 3.16. Sentencias CASE

# 3.21. Uso de Particiones en las Tablas

# Reglas nuevas:

# 1.19. Creación de Vistas

# 3.2. SELECT a Vistas de Fuentes de Datos Productivas

# 3.3. Filtrado a Fuentes de Datos Productivas

# 3.9.2. Cláusula ON

# 1. Confección de BTEQs

El siguiente apartado especifica las normas de confección de BTEQs de Teradata para los desarrollos de procesos de Airflow CRM 2.0.

# 1.1. ❌ Organización y Máximo de Líneas de BTEQs

Para una correcta organización, cada script de BTEQ debe abordar un solo concepto de Negocio/Extracción. Además, las BTEQs deben estar compuestas por un número razonable de líneas, con un límite máximo de 1500.

Ejemplo:

Público objetivo

Cálculo de variables demográficas





Cálculo de variables de producto

Aplicar reglas de negocio

Aplicar saturación

Unión de universo

Construcción tabla de salida

Si la BTEQ es pequeña, dentro del mismo archivo .sql deben ir separados estos conceptos o áreas, para tener claridad en una eventual mantención.

# 1.2. ⚠ Nombres de BTEQs

Para una correcta identificación y ordenación en el DAG, las BTEQs deben llevar un prefijo numérico correlativo. Adicionalmente, el nombre de cada BTEQ debe ser descriptivo, abarcando un único concepto de Negocio/Extracción que clarifique su propósito.

| Ejemplo Secuencial:               | Ejemplo Paralelo:                 |
| --------------------------------- | --------------------------------- |
| 000\_Creacion\_Tablas\_Historicas | 000\_Creacion\_Tablas\_Historicas |
| 001\_Construccion\_Universo\_Pym  | 001\_Creacion\_Ruteo              |
| e                                 | 002\_A\_Variables\_Demograficas   |
| 002\_Tenencia\_Producto\_Pyme     | 002\_B\_Variables\_Deuda          |

# 1.3. ⚠ Encabezado de BTEQ

Toda BTEQ debe iniciar con un encabezado que cumpla con las siguientes características:

- Descripción a nivel de negocio de lo que hace el script.
- Autor, conformado por Nombre y Apellido, no se debe colocar iniciales o nombres de usuario.
- Fecha de creación del script.
- Se deben especificar todas las tablas de entrada del proceso, estas tablas son aquellas fuentes que no se generan en el propio script. Se debe validar que todas las tablas del encabezado se estén usando en el script y que todas las tablas del script se encuentren en el encabezado.
- Se debe especificar la o las tablas de salida del proceso, con la correcta nomenclatura.

Lo correcto:

1  /******************************************************************************************
2  *******************************************************************************************
3  ** DSCRPCN: SELECCION DE UNIVERSO INICIAL PARA JOURNEY LEAKAGE RESCATES                   **
4  **          UNIVERSO INICIAL CONSISTENTE EN CLIENTES QUE ESTAN EN EL MODELO ANALITICO     **





# AUTOR: MIGUEL CHAMPIN

# FECHA: 01/2023

# 1.4. ❌ Sentencias de Inicio y Fin de BTEQ

Se deben agregar las siguientes sentencias dentro de la BTEQ:

Al inicio de la BTEQ:

.SET   SESSION CHARSET 'UTF-8';
SELECT DATE,    TIME;
SET    QUERY_BAND = 'Pry=Nombre_Proyecto;Journey=Nombre_Jny;Bteq=Nombre_Bteq;' FOR SESSION;

Al final de la BTEQ:

SELECT DATE, TIME;
.LOGOFF;
.QUIT 0;

Esto es para poder ver el tiempo real de ejecución de un script completo. De esta manera, podemos analizar si la performance de un proceso podría o no afectar el rendimiento de la máquina y/o los procesos que ya están en producción.

# 1.5. ⚠ Comentarios de Encabezado

Los comentarios del encabezado que describen el proceso deben ser a nivel de una descripción de negocio que explique claramente de qué se trata el proceso en cuestión. No deben ser comentarios genéricos.

Lo que no se debe hacer:

/******************************************************************************************
**                             CARGA DE DATOS A MKTC                                       **
******************************************************************************************/

Lo correcto:

/******************************************************************************************
**    CARGA DE CLIENTES CUENTACORRENTISTA CON BCIPASS HABILITADO A MKTC    **
******************************************************************************************/



# 1.6. ⚠ Comentarios de Sentencias

Los comentarios de las sentencias SQL deben describir a nivel de negocio y no técnico dicha sentencia.

Lo que no se debe hacer:

1 /* Se inserta información de cliente desde la tabla XXXX */
Lo correcto:

1     /* Se inserta clientes de inversiones DAP y FM con saldo para los 3 últimos meses */
Adicionalmente, se permite el uso de comentarios dentro de las líneas de código, siempre y cuando contribuyan a una explicación a nivel de negocio:

1     WHERE NOT(IA.Ic_Origen_Fuga='DAP') --Clientes cuyo origen de fuga no sea Deposito a Plazo

# 1.7. ⚠ Creación de Tablas Temporales

La creación debe ser explícita, es decir, definir todos sus campos e índice primario. No se permite la creación implícita mediante la sentencia CREATE AS SELECT. El nombre debe ser descriptivo de acuerdo a los datos que contenga. Debe realizar el DROP TABLE antes de la creación. Una vez insertados los datos en la tabla se debe realizar un COLLECT de las estadísticas necesarias. Al finalizar el proceso la tabla temporal debe ser dropeada. Revisar el documento de nomenclatura para nombrar las tablas en cuestión.

Cuando haya más de una inserción en una tabla, el COLLECT deberá realizarse una vez completada la última inserción.

# 1.7.1. ❌ Tablas con Prefijo T

Las tablas con prefijo T (tablas temporales) deben estar siempre en esquemas temporales y deben ser eliminadas al finalizar el DAG.

Lo que no se debe hacer:

1     CREATE TABLE {{ var.value.BD_JOURNEY }}.T_Opd_Con_1A_Consumo_Param_Fecha
2     (
3       Tc_Fecha_Ref CHAR(8) CHARACTER SET LATIN NOT CASESPECIFIC
4       ,Tf_Fecha_Ref_Dia DATE FORMAT 'YYYY-MM-DD'





# 1.7.2. ❌ Tablas con Prefijo P

Las tablas con prefijo P (tablas de precálculo) deben quedar en el esquema temporal y se deben eliminar al finalizar el DAG.

# 1.8. ❌ Sentencias SELECT

Las sentencias SQL deben ser escritas de forma ordenada en líneas separadas para poder entender de forma fácil lo que se está realizando con la misma. Además, siempre deben finalizar con un punto y coma ( ; ) para identificar el término de ésta.

Tampoco se permite el uso de asterisco ( * ) dentro del SELECT , los campos deben ser listados de forma explícita.

# Lo que no se debe hacer:

1    Select * from edw_vw.agreement where acct_status_type_cd = 1;

# Lo correcto:

1    SELECT
2     Account_Num               AS  Tc_Account_Num
3     ,Account_Modifier_Num     AS  Tc_Account_Modifier_Num
4     ,Acct_Status_Type_Cd      AS  Te_Acct_Status_Type_Cd
5    FROM
6     EDW_VW.Agreement
7    WHERE
8     Acct_Status_Type_Cd =    1;

# 1.9. ⚠ Indentación

Debe garantizarse una correcta indentación de las queries. Esto quiere decir lo siguiente:

- a. Los campos del SELECT deben llevar una sangría.





# Lo que no se debe hacer:

1  SELECT Tf_MES_INI_VIG,Te_RUT,Te_Party_Id,Tc_BANCA
2  ,Tf_INI_EJE_DEST,  Tf_FIN_EJE_DEST,
3  FROM MKT_TMP_INPUT_TB.T_UNIV_CAMB_EJE_CONT30D;

# Lo correcto:

1    SELECT
2     Tf_Mes_Ini_Vig
3     ,Te_RUT
4     ,Te_Party_Id
5     ,Tc_Banca
6     ,Tf_Ini_Eje_Dest
7     ,Tf_Fin_Eje_Dest
8    FROM MKT_TMP_INPUT_TB.T_UNIV_CAMB_EJE_CONT30D;

b. Las comas que separan los campos del SELECT deben ir a la izquierda.

# Lo que no se debe hacer:

1  SELECT
2  Tf_Mes_Ini_Vig,
3  Te_RUT,
4  Te_Party_Id,
5  Tc_Banca,
6  Tf_Ini_Eje_Dest,
7  Tf_Fin_Eje_Dest
8  FROM MKT_TMP_INPUT_TB.T_UNIV_CAMB_EJE_CONT30D;

# Lo correcto:

1    SELECT
2     Tf_Mes_Ini_Vig
3     ,Te_RUT
4     ,Te_Party_Id
5     ,Tc_Banca
6     ,Tf_Ini_Eje_Dest
7     ,Tf_Fin_Eje_Dest
8    FROM MKT_TMP_INPUT_TB.T_UNIV_CAMB_EJE_CONT30D;

c. Los ON deben ir debajo del JOIN.




# Lo que no se debe hacer:

1    SELECT
2     TRF.Te_RUT_Origen            AS  Te_RUT_Origen
3     ,TRF.Te_RUT_Destino          AS  Te_RUT_Destino
4     ,PAR.Pf_Fecha_Ref_Dia        AS  Pf_Fecha_Ref_Dia
5     ,TRF.Tf_Fecha_Trf            AS  Tf_Fecha_Trf
6     ,MIN(CCT.Tf_Fecha_Apertura)  AS  Tf_Fecha_Pln
7    FROM
8     MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO AS  TRF
9     INNER JOIN MKT_TMP_INPUT_TB.P_TPP_PARAMETRO_FECHAS AS PAR ON  TRF.Tf_Fecha_Trf >=
PAR.Pf_Fecha_Menos_12M
10     LEFT JOIN MKT_TMP_INPUT_TB.T_PRE_TPP_TENENCIA_CTACTE AS CCT   ON TRF.Te_RUT_Destino =
CCT.Te_RUT
11    WHERE COALESCE(CCT.Tf_Fecha_Apertura, TRF.Tf_Fecha_Trf + 1) >  TRF.Tf_Fecha_Trf
12    GROUP BY
13     TRF.Te_RUT_Origen
14     ,TRF.Te_RUT_Destino
15     ,PAR.Pf_Fecha_Ref_Dia
16     ,TRF.Tf_Fecha_Trf;

# Lo correcto:

1    SELECT
2     TRF.Te_RUT_Origen             AS  Te_RUT_Origen
3     ,TRF.Te_RUT_Destino           AS  Te_RUT_Destino
4     ,PAR.Pf_Fecha_Ref_Dia         AS  Pf_Fecha_Ref_Dia
5     ,TRF.Tf_Fecha_Trf             AS  Tf_Fecha_Trf
6     ,MIN(CCT.Tf_Fecha_Apertura)   AS  Tf_Fecha_Pln
7    FROM  MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO  AS TRF
8     INNER JOIN MKT_TMP_INPUT_TB.P_TPP_PARAMETRO_FECHAS AS PAR
9          ON TRF.Tf_Fecha_Trf >= PAR.Pf_Fecha_Menos_12M
10     LEFT JOIN MKT_TMP_INPUT_TB.T_PRE_TPP_TENENCIA_CTACTE AS CCT
11          ON TRF.Te_RUT_Destino =  CCT.Te_RUT
12    WHERE COALESCE(CCT.Tf_Fecha_Apertura, TRF.Tf_Fecha_Trf + 1) > TRF.Tf_Fecha_Trf
13    GROUP BY
14     TRF.Te_RUT_Origen
15     ,TRF.Te_RUT_Destino
16     ,PAR.Pf_Fecha_Ref_Dia
17     ,TRF.Tf_Fecha_Trf;

# d. Los comparadores lógicos (AND, OR, NOT, etc.) no deben ir a la izquierda de las sentencias lógicas.

# Lo que no se debe hacer:

1    SELECT
2     UNI.Te_Per_RUT           AS  Te_Per_RUT
3     ,UNI.Tc_Per_Dv           AS  Tc_Per_Dv
4     ,UNI.Te_Per_Party_Id     AS  Te_Per_Party_Id




# Lo correcto:

SELECT
UNI.Te_Per_RUT           AS  Te_Per_RUT
,UNI.Tc_Per_Dv           AS  Tc_Per_Dv
,UNI.Te_Per_Party_Id     AS  Te_Per_Party_Id
,UNI.Tc_Per_CIC          AS  Tc_Per_CIC
,UNI.Tf_Per_Fecha_Info   AS  Tf_Per_Fecha_Info
,UNI.Te_Per_Cant_Con     AS  Te_Per_Cant_Con
,UNI.Te_Per_Cant_Hip     AS  Te_Per_Cant_Hip
FROM  EDW_TEMPUSU.T_STG_PER_1A_CLI_IND_H UNI
LEFT JOIN EDW_TEMPUSU.PBD_CLIENTES_CAMBIANTES_2 CCA
ON  UNI.Te_Per_Party_Id    = CCA.Party_Id
AND  CCA.Campo_Type_Cd =    20
AND  CCA.Estado = 1;

# Lo que no se debe hacer:

WHERE
UNI.Te_Per_Party_Id = CCA.Party_Id AND CCA.Campo_Type_Cd = 20 AND CCA.Estado = 1;

# Lo correcto:

WHERE
UNI.Te_Per_Party_Id = CCA.Party_Id
AND  CCA.Campo_Type_Cd = 20
AND  CCA.Estado = 1;

# f. Los tipos de campos deben estar separados por la cantidad de sangría necesaria respecto a los nombres para que queden alineados.





# CREATE TABLE EDW_TEMPUSU.T_STG_PER_1A_CLI_VAR_DEMO

(
Td_Rut             DECIMAL(8,0)
,Tc_Banca          VARCHAR(100)  CHARACTER  SET  LATIN NOT  CASESPECIFIC
,Tc_Banca_Desc     VARCHAR(100)  CHARACTER  SET  LATIN NOT  CASESPECIFIC
,Tc_Segmento       VARCHAR(100)  CHARACTER  SET  LATIN NOT  CASESPECIFIC
,Tc_Segmento_Desc  VARCHAR(100)  CHARACTER  SET  LATIN NOT  CASESPECIFIC
)  PRIMARY INDEX (Td_Rut);

# g. Los CASE WHEN no deben organizarse de forma horizontal cuando tienen más de una comparación lógica.

# Lo que no se debe hacer:

SELECT
Te_Rut                     AS  Te_RUT
,Te_Periodo_Ref            AS  Te_Periodo_Ref
,Tf_Fecha_Ref_Dia          AS  Tf_Fecha_Ref_Dia
,COUNT(1)                  AS  Te_Num_Bancos
,SUM(Td_Monto_Transf)      AS  Td_Monto_Transf_1_Ano
,MAX(Td_Max_Monto_Transf)  AS  Td_Max_Monto_Transf
,AVG(Td_Monto_Transf_Avg)  AS  Td_Mto_Transf_1Ano_Prom
,MIN(CASE WHEN Tc_Banco_Destino='BANCO DE CHILE' THEN '1-CHILE' WHEN
Tc_Banco_Destino='BANCO SANTANDER-CHILE' THEN '2-SANTANDER'
WHEN Tc_Banco_Destino='BANCO DEL ESTADO DE CHILE' THEN '3-BANCOESTADO' ELSE '4-OTROS'
END)                       AS  Tc_Banco
FROM  MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_01
GROUP BY
Te_RUT
,Te_Periodo_Ref
,Tf_Fecha_Ref_Dia;

# Lo correcto:

SELECT
Te_Rut                    AS  Te_RUT
,Te_Periodo_Ref           AS  Te_Periodo_Ref
,Tf_Fecha_Ref_Dia         AS  Tf_Fecha_Ref_Dia
,COUNT(1)                 AS  Te_Num_Bancos
,SUM(Td_Monto_Transf)     AS  Td_Monto_Transf_1_Ano
,MAX(Td_Max_Monto_Transf) AS  Td_Max_Monto_Transf
,AVG(Td_Monto_Transf_Avg) AS  Td_Mto_Transf_1Ano_Prom
,MIN(CASE WHEN Tc_Banco_Destino='BANCO DE CHILE'
THEN '1-CHILE'
WHEN Tc_Banco_Destino='BANCO SANTANDER-CHILE'
THEN '2-SANTANDER'
WHEN Tc_Banco_Destino='BANCO DEL ESTADO DE CHILE'
THEN '3-BANCOESTADO'
ELSE '4-OTROS'
END)                      AS  Tc_Banco
FROM  MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_01





# 1.10. Alias

# 1.10.1. ⚠ Alias de Tablas

Estos deben ser de a lo menos 3 siglas descriptivas respecto de la tabla y deben ser utilizados tanto en tablas como en los campos.

En caso de que la sentencia SELECT contenga solo una tabla, no es necesario utilizar el Alias de Tablas.

Lo que no se debe hacer:

SELECT
A.Pe_RUT              AS  Td_RUT
,Pe_Periodo_Ref       AS  Te_Periodo_Ref
,Pf_Fecha_Ref_Dia     AS  Tf_Fecha_Ref_Dia
,B.Te_RUT_Origen      AS  Te_RUT_Origen
,COUNT(1)             AS  Te_Cantidad_Trf
FROM
MKT_TMP_INPUT_TB.P_TPP_PUBLICO_OBJETIVO AS A
INNER JOIN MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO AS B
GROUP BY
A.Pe_Rut
,Pe_Periodo_Ref
,Pf_Fecha_Ref_Dia
,B.Te_RUT_Origen;

Lo correcto:

SELECT
POB.Pe_RUT                AS  Td_RUT
,POB.Pe_Periodo_Ref       AS  Te_Periodo_Ref
,POB.Pf_Fecha_Ref_Dia     AS  Tf_Fecha_Ref_Dia
,TRF.Te_RUT_Origen        AS  Te_RUT_Origen
,COUNT(1)                 AS  Te_Cantidad_Trf
FROM  MKT_TMP_INPUT_TB.P_TPP_PUBLICO_OBJETIVO AS POB
INNER JOIN MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO AS TRF
ON   POB.Pe_Rut =     TRF.Te_Rut_Destino
GROUP BY
POB.Pe_Rut
,POB.Pe_Periodo_Ref
,POB.Pf_Fecha_Ref_Dia
,TRF.Te_RUT_Origen;




# 1.10.2. ⚠ Alias de Campos

Deben ser iguales al nombre de los campos de la tabla de destino donde serán insertados.

En caso de que la sentencia SELECT contenga solo una tabla, no es necesario utilizar el Alias de Campos.

Lo que no se debe hacer:

CREATE TABLE MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_01
(
Td_Rut                       DECIMAL (8,0)
,Te_Periodo_Ref              INTEGER
,Tf_Fecha_Ref_Dia            DATE FORMAT 'YYYY-MM-DD'
,Te_Num_Bancos               INTEGER
,Td_Monto_Transf_1_Ano       DECIMAL(25,10)
,Td_Max_Monto_Transf         DECIMAL(25,10)
,Td_Mto_Transf_1Ano_Prom     DECIMAL(25,10)
,Tc_Banco                    CHAR(40) CHARACTER SET LATIN NOT CASESPECIFIC
)  PRIMARY INDEX (Td_RUT,    Tf_Fecha_Ref_Dia, Te_Periodo_Ref);
.IF ERRORCODE   &#x3C;>   0  THEN .QUIT 25;

SELECT

Te_Rut
,Te_Periodo_Ref
,Tf_Fecha_Ref_Dia
,COUNT(1)
,SUM(Td_Monto_Transf)
,MAX(Td_Max_Monto_Transf)
,AVG(Td_Monto_Transf_Avg)
,MIN(CASE WHEN Tc_Banco_Destino='BANCO DE CHILE'
THEN '1-CHILE'
WHEN Tc_Banco_Destino='BANCO SANTANDER-CHILE'
THEN '2-SANTANDER'
WHEN Tc_Banco_Destino='BANCO DEL ESTADO DE CHILE'
THEN '3-BANCOESTADO'
ELSE '4-OTROS'
END)

Lo correcto:

CREATE TABLE MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_01
(
Td_Rut                       DECIMAL (8,0)
,Te_Periodo_Ref              INTEGER
,Tf_Fecha_Ref_Dia            DATE FORMAT 'YYYY-MM-DD'
,Te_Num_Bancos               INTEGER
,Td_Monto_Transf_1_Ano       DECIMAL(25,10)
,Td_Max_Monto_Transf         DECIMAL(25,10)
,Td_Mto_Transf_1Ano_Prom     DECIMAL(25,10)
,Tc_Banco                    CHAR(40) CHARACTER SET LATIN NOT CASESPECIFIC
)  PRIMARY INDEX (Td_RUT,    Tf_Fecha_Ref_Dia, Te_Periodo_Ref);



# 1.11. ❌ Campos dentro de GROUP BY

Los campos dentro del GROUP BY deben ser nombrados y no numerados.

# Lo que no se debe hacer:

SELECT
a.Td_RUT
,a.Tf_Fecha_Ejec
,a.Tc_Id_Gatillo
,b.Sc_Gatillo
,CAST(a.Tf_Fecha_Ejec AS INTEGER) AS Te_Fecha_Ejec
FROM EDW_TEMPUSU.T_CRM_PYME_1A_GEN_CCOP8 a
LEFT JOIN MKT_CRM_ANALYTICS_TB.S_STG_TMP_EMP_1A_PARAMETROS b
ON a.Tc_Id_Gatillo=b.Sc_Id_Gatillo
GROUP BY 1,2,3,4,5;

# Lo correcto:

SELECT
a.Td_RUT
,a.Tf_Fecha_Ejec
,a.Tc_Id_Gatillo
,b.Sc_Gatillo
FROM
EDW_TEMPUSU.T_CRM_PYME_1A_GEN_CCOP8 a
LEFT JOIN MKT_CRM_ANALYTICS_TB.S_STG_TMP_EMP_1A_PARAMETROS b
ON a.Tc_Id_Gatillo=b.Sc_Id_Gatillo
GROUP BY
a.Td_RUT
,a.Tf_Fecha_Ejec
,a.Tc_Id_Gatillo
,b.Sc_Gatillo





# 1.12. ❌ Validación de Resultados

Después de cada ejecución de una sentencia SQL se debe validar el resultado con las instrucciones:

1     .IF  {expresión-comparativa} THEN .QUIT N;

Ejemplos:

1     .IF  ACTIVITYCOUNT >  0 THEN .QUIT 8;
1     .IF  ERRORCODE  &#x3C;> 0 THEN .QUIT 9;

Con esto, si el resultado es distinto a 0 (cero), se cancela el proceso.

Estos errores de código deben ser correlativos respecto a la cantidad de validaciones que existan dentro de la propia BTEQ.

*Solo se excluye de esta regla la sentencia DROP TABLE cuando se requiere eliminar una tabla temporal de paso. Esto, porque se asume que la tabla no debiese existir. Sin embargo, en caso de un reproceso podría no ser así y no se espera que el proceso falle por esa razón.

# 1.13. ❌ Comprobaciones

Dentro de los procesos BTEQ está permitido realizar comprobaciones a algunas condiciones especiales a fin de tomar una dirección u otra dentro del código construido, como por ejemplo el realizar una inserción a una tabla dependiendo de si está vacía o no, eliminar ciertos registros de otra, etc.

Estas se realizan a través de las sentencias .IF, .GOTO y .LABEL.

Un ejemplo de esto sería lo siguiente:

1     /* Valida que la tabla temporal tenga registros */
2     SELECT DISTINCT
3        Fec_Encuesta
4     FROM  {{ var.value.BD_TEMP_JOURNEY }}.T7966_Fld_CtlgP_BEio;
5     .IF  ERRORCODE &#x3C;> 0 THEN .GOTO CTLGP_NOK;
6     .IF  ACTIVITYCOUNT >   0 THEN .GOTO CTLGP_OK;
7     /* Si no hay registros aborta el proceso */
8     .LABEL CTLGP_NOK;
9     SELECT
10        'TABLA ${EDW_TEMP}.T7966_Fld_CtlgP_BEio NO EXISTE O SIN DATOS';
11     .QUIT 1;
12     /* Si hay registros continua el proceso */
13     .LABEL CTLGP_OK;
14     SELECT DISTINCT
15        Fec_Encuesta
16     FROM  {{ var.value.BD_TEMP_JOURNEY }}.T7966_Fld_CtlgP_BEio





# 1.14. Estadísticas

Las estadísticas son algo fundamental para que el optimizador del motor Teradata pueda armar el mejor plan de ejecución para las consultas, lo que resulta en queries más eficientes y con mejor performance, ya que el motor “sabe” cómo se comportan los datos.

La recolección de estadísticas se debe realizar cada vez que se insertan datos sobre las tablas, ya sean temporales del proceso o de modelos finales. Estas deben ser realizadas sólo a los campos (o grupos de campos) relevantes, es decir, índices y campos utilizados para cruces en las consultas posteriores, en ningún caso aplica a toda la tabla.

Se puede realizar estadísticas a todas las tablas a las que el perfil de usuario permita realizar operaciones de INSERT, por lo que no es posible hacerlo a otras tablas de modelo que deban ser consultadas dentro del proceso.

Existen 2 formas de realizar la recolección de estadísticas: a todos los registros de la tabla o a una muestra representativa. Lo realizaremos a todos los registros si sabemos que su volumetría no es muy grande y a una parte en caso contrario, esto se hace de la siguiente forma:

1. A una muestra de los registros

1  /* Estadísticas de base.tabla */
2  DIAGNOSTIC "COLLECTSTATS, SAMPLESIZE=70" ON FOR SESSION;
3  COLLECT STATISTICS USING SAMPLE
4  INDEX (campo1)
5  ,COLUMN (campo2)
6  ON base.tabla
7  ;

Esto aplicará estadísticas a los campos índice (campo1) y columna (campo2) para el 70% de los registros.

A todos los registros

1  /* Estadísticas de base.tabla */
2  COLLECT STATISTICS
3  INDEX (campo1)
4  ,COLUMN(campo2)
5  ON base.tabla
6  ;

Esto aplicará estadísticas a los campos índice (campo1) y columna (campo2) para todos los registros de la tabla.






Cuando haya más de una inserción en una tabla, el COLLECT deberá realizarse una vez completada la última inserción.

# 1.15. ❌ Borrado de Tablas Temporales

Se debe crear un script al final del DAG donde se eliminen todas las tablas que estén en esquema temporal.

SELECT DATE, TIME;
DROP TABLE EDW_TEMPUSU.T_CREA_VARIABLES_CON_PROB;
DROP TABLE EDW_TEMPUSU.T_CREA_VARIABLES_CON_PROB_CONTEO;
DROP TABLE EDW_TEMPUSU.T_CREA_VARIABLES_CON_PROB_CONSOLIDADO;
SELECT DATE, TIME;
.QUIT 0;

# 1.16. ❌ Procesos Reprocesables

Los procesos deben ser reprocesables, es decir se pueden procesar nuevamente sin intervención directa en el código. En caso que no sea reprocesable se debe justificar.

# 1.17. ❌ Procesos Idempotentes

Esta propiedad nos dice que independiente de la cantidad de veces que se ejecute el proceso, el resultado no debe cambiar. Es decir, una operación computacional se considera idempotente si siempre produce el mismo resultado.

Para nuestro caso, las ejecuciones de procesos siempre deben producir la misma salida. Para esto debemos incluir dentro del desarrollo lógicas que permitan el reproceso independiente de las veces que se ejecuten, si debemos intervenir la tarea de forma manual para que el resultado sea el esperado no estamos cumpliendo con esta propiedad.

La idempotencia suele ser inseparable de la reproducibilidad: un conjunto de entradas siempre produce el mismo conjunto de salidas.

# 1.18. ❌ Creación de Tabla Histórica

Debe existir una BTEQ 000 donde se agregue el CREATE de las tablas que no tengan un CREATE TABLE dentro del proceso (por ejemplo: las tablas históricas). Esta BTEQ no debe enmallarse dentro del DAG.




JNY_098_INVO23_CLUSTER_5_INVERSIONES
Además, esta BTEQ debe contener los esquemas exactos donde irán las tablas y no se deben utilizar variables de entorno en su confección. Tampoco se deben incluir las sentencias DROP TABLE en caso de la tabla no exista.

El archivo debe ir tal cual como se necesita que se ejecute.

# Lo que no se debe hacer:

1    DROP TABLE {{ var.value.BD_JOURNEY }}.I_Jny_Plan_Dig_Nomina_Nuevos;
2    CREATE MULTISET TABLE {{ var.value.BD_JOURNEY }}.I_Jny_Plan_Dig_Nomina_Nuevos
3    (
4     Ic_Contact_Account_Id       VARCHAR(100)  CHARACTER  SET          LATIN NOT  CASESPECIFIC
5     ,  Ic_PersonContact_Id      VARCHAR(100)  CHARACTER  SET          LATIN NOT  CASESPECIFIC
6     ,  Ic_Account_Id            VARCHAR(100)  CHARACTER  SET          LATIN NOT  CASESPECIFIC
7     ,  Ic_Owner_Id              VARCHAR(100)  CHARACTER  SET          LATIN NOT  CASESPECIFIC
8     ,  Ic_Nombre_Iniciativa     VARCHAR(50)  CHARACTER SET         LATIN NOT    CASESPECIFIC
9     ,  If_Fecha_Inicio          DATE FORMAT 'YYYY-MM-DD'
10     ,  If_Fecha_Fin             DATE FORMAT 'YYYY-MM-DD'
11     ,  If_Fecha_Envio           DATE FORMAT 'YYYY-MM-DD'
12    )
13    PRIMARY INDEX (Ic_Contact_Account_Id);

# Lo correcto:

1    CREATE MULTISET TABLE MKT_JOURNEYBUILDER_TB.I_Jny_Plan_Dig_Nomina_Nuevos
2    (
3     Ic_Contact_Account_Id       VARCHAR(100)  CHARACTER  SET          LATIN NOT  CASESPECIFIC
4     ,  Ic_PersonContact_Id      VARCHAR(100)  CHARACTER  SET          LATIN NOT  CASESPECIFIC
5     ,  Ic_Account_Id            VARCHAR(100)  CHARACTER  SET          LATIN NOT  CASESPECIFIC
6     ,  Ic_Owner_Id              VARCHAR(100)  CHARACTER  SET          LATIN NOT  CASESPECIFIC
7     ,  Ic_Nombre_Iniciativa     VARCHAR(50)  CHARACTER SET         LATIN NOT    CASESPECIFIC
8     ,  If_Fecha_Inicio          DATE FORMAT 'YYYY-MM-DD'
9     ,  If_Fecha_Fin             DATE FORMAT 'YYYY-MM-DD'
10     ,  If_Fecha_Envio           DATE FORMAT 'YYYY-MM-DD'
11    )
12    PRIMARY INDEX (Ic_Contact_Account_Id);

# 1.19. ❌ Creación de Vistas

En caso de que el proceso necesite crear una vista de una tabla final, esta debe existir en una BTEQ 000, donde se agregue el CREATE VIEW. Esta BTEQ no debe enmallarse dentro del DAG.





JNY_098_INVO23_CLUSTER_5_INVERSIONES

Es importante que la creación de la vista incluya la siguiente sentencia "LOCKING TABLE base.tabla FOR ACCESS NOWAIT", puesto que permite la lectura concurrente y evita bloqueos de acceso a la tabla original.

Además, esta BTEQ debe contener los esquemas exactos donde irán las tablas y no se deben utilizar variables de entorno en su confección. Tampoco se deben incluir las sentencias DROP VIEW en caso de la vista no exista.

El archivo debe ir tal cual como se necesita que se ejecute.

# Lo que no se debe hacer:

1    DROP VIEW {{ var.value.BD_DOMBCI_VW }}.I_GA_NAV_FFMM_CARTERA_WEB;
2
3    CREATE VIEW {{ var.value.BD_DOMBCI_VW }}.I_GA_NAV_FFMM_CARTERA_WEB AS
4    SELECT
5          Id_Fecha
6          ,Ic_DimensionID
7          ,Id_Cli_Rut
8          ,Ic_pagePath
9          ,IC_pageTitle
10          ,Ie_uniquePageViews
11          ,Ie_PageViews
12          ,If_Process_date
13    FROM
14         {{ var.value.BD_DOMBCI }}.I_GA_NAV_FFMM_WEB
15    ;
16    .IF  ERRORCODE &#x3C;> 0 THEN .QUIT 001;

# Lo correcto:

1    CREATE VIEW DOM_BCI_PRD_VW.I_GA_NAV_FFMM_CARTERA_WEB AS
2    LOCKING TABLE DOM_BCI_PRD_TB.I_GA_NAV_FFMM_CARTERA_WEB FOR ACCESS NOWAIT
3    SELECT
4          Id_Fecha
5          ,Ic_DimensionID
6          ,Id_Cli_Rut
7          ,Ic_pagePath
8          ,IC_pageTitle
9          ,Ie_uniquePageViews
10          ,Ie_PageViews
11          ,If_Process_date
12    FROM
13         DOM_BCI_PRD_TB.I_GA_NAV_FFMM_WEB
14    ;





# 1.20. ❌ Prueba de BTEQs

Todas las querys deben ser probadas y ejecutadas en su totalidad, antes de ser enmalladas.

# 2. Formato de Datos

El siguiente apartado especifica las normas de formato de datos en BTEQs de Teradata para los desarrollos de procesos de Airflow CRM 2.0.

# 2.1. ⚠ RUT de Clientes

Deben colocarse en formato  DECIMAL(9,0).

Muchas veces se trabaja con un conjunto universo que trae RUTs con más de 9 dígitos los cuales son RUTs inválidos. Por ejemplo, al extraer erróneamente el rut desde la tabla EDW_VW.EXTERNAL_IDENTIFICATION_HIST.

Si se crea este dato como un campo de DECIMAL(9,0) al venir un RUT más grande se generará un error de overflow el cual permitirá visualizar el error para posteriormente reparar dicha situación y mejorar la query con la cual se está trabajando.

Lo que no se debe hacer:

1    CREATE TABLE MKT_TMP_JOURNEYBUILDER_TB.T_PRE_TPP_TRF_BCI_OTBCO_02
2    (
3     Te_Rut                 INTEGER
4     ,Te_Periodo_Ref        INTEGER
5     ,Tf_Fecha_Ref_Dia      DATE FORMAT 'YYYY-MM-DD'

Lo correcto:

1    CREATE TABLE MKT_TMP_JOURNEYBUILDER_TB.T_PRE_TPP_TRF_BCI_OTBCO_02
2    (
3     Td_Rut                DECIMAL(9,0)
4     ,Te_Periodo_Ref       INTEGER
5     ,Tf_Fecha_Ref_Dia     DATE FORMAT 'YYYY-MM-DD'

*Para procesos que se conecten a Marketing Cloud donde el Data Extension tenga definido el rut como INTEGER, ese campo se puede dejar en la última tabla del proceso como INTEGER para que no tenga inconsistencias con Marketing Cloud.

# 2.2. ❌ Tipo de Campo DATE

Debe ir acompañado del formato FORMAT 'YYYY-MM-DD'.






# Lo que no se debe hacer:

1    CREATE TABLE MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_02
2    (
3     Td_Rut                 DECIMAL(8,0)
4     ,Te_Periodo_Ref        INTEGER
5     ,Tf_Fecha_Ref_Dia      DATE

# Lo correcto:

1    CREATE TABLE MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_02
2    (
3     Td_Rut                 DECIMAL(8,0)
4     ,Te_Periodo_Ref        INTEGER
5     ,Tf_Fecha_Ref_Dia      DATE FORMAT 'YYYY-MM-DD'

# 2.3. ❌ Tipo de Campo CHAR o VARCHAR

Deben ir acompañados con la sentencia CHARACTER SET LATIN NOT CASESPECIFIC.

El largo del campo CHAR debe ser de máximo 255 caracteres y el largo del campo VARCHAR debe ser de máximo 64000 caracteres, los cuales son los límites de uso de Teradata.

En caso de que el string sea menor o igual a 4 caracteres, este obligatoriamente debe ser CHAR.

Si los valores del campo son de un tamaño conocido, se recomienda que este campo sea del tipo CHAR.

# Lo que no se debe hacer:

1    CREATE TABLE MKT_TMP_JOURNEYBUILDER_TB.T_PRE_TPP_TRF_BCI_OTBCO_03
2    (
3     Td_Rut                 DECIMAL(8,0)
4     ,Tc_Banco              VARCHAR(4)

# Lo correcto:

1    CREATE TABLE MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_03
2    (
3     Td_Rut        DECIMAL(8,0)
4     ,Tc_Banco     CHAR(4) CHARACTER SET LATIN NOT          CASESPECIFIC





# 2.4. ⚠ Sentencia COMPRESS

Los campos, en la medida que se pueda, deben ir acompañados con una sentencia COMPRESS en los valores que más repiten en la tabla.

Lo correcto:

1        CREATE TABLE MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_03
2        (
3           Td_Rut        DECIMAL(8,0)
4           ,Tc_Banco     CHAR(40)   CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS
('Bci','Chile','Santander')

El objetivo de usar COMPRESS es reducir el tamaño de almacenamiento de las tablas.

# 2.5. ❌ Tipo de Datos FLOAT

No se deben usar el tipo de dato FLOAT. El mismo debe ser reemplazado por el tipo de dato DECIMAL correspondiente.

Solo se pueden usar tipo de datos FLOAT en los modelos analíticos, pero debe estar validado y plenamente justificado por el proceso de negocio asociado.

Lo que no se debe hacer:

1     CREATE TABLE MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_01
2     (
3        Td_Rut                       DECIMAL (8,0)
4        ,Te_Periodo_Ref              INTEGER
5        ,Tf_Fecha_Ref_Dia            DATE FORMAT 'YYYY-MM-DD'
6        ,Te_Num_Bancos               INTEGER
7        ,Td_Monto_Transf_1_Ano       FLOAT
8        ,Td_Max_Monto_Transf         FLOAT
9        ,Td_Mto_Transf_1Ano_Prom     DECIMAL(25,10)
10        ,Tc_Banco                    CHAR(40) CHARACTER SET LATIN NOT CASESPECIFIC
11     )  PRIMARY INDEX (Td_RUT,    Tf_Fecha_Ref_Dia, Te_Periodo_Ref)
12     ;

Lo correcto:

1    CREATE TABLE MKT_TMP_INPUT_TB.T_PRE_TPP_TRF_BCI_OTBCO_01
2    (
3     Td_Rut                       DECIMAL (8,0)
4     ,Te_Periodo_Ref              INTEGER
5     ,Tf_Fecha_Ref_Dia            DATE FORMAT 'YYYY-MM-DD'
6     ,Te_Num_Bancos               INTEGER
7     ,Td_Monto_Transf_1_Ano       DECIMAL(25,10)
8     ,Td_Max_Monto_Transf         DECIMAL(25,10)
9     ,Td_Mto_Transf_1Ano_Prom     DECIMAL(25,10)





10        ,Tc_Banco              CHAR(40) CHARACTER SET LATIN NOT CASESPECIFIC
11     )  PRIMARY INDEX (Td_RUT, Tf_Fecha_Ref_Dia, Te_Periodo_Ref)
12     ;

Se recomienda que para los campos que tengan relación con montos, estos se almacenen en
un campo de tipo        DECIMAL , tanto en las BTEQs como en el Data Extension de Marketing

Cloud. Esto debido a que el tipo de dato   Number de Marketing Cloud tiene las mismas

limitaciones que un tipo de dato  INTEGER , por lo que no puede almacenar números a partir
de cierto largo.

# 3. Condiciones, Prohibiciones y Recomendaciones

El siguiente apartado especifica las condiciones, prohibiciones y recomendaciones respecto al
desarrollo de BTEQs de Teradata para los desarrollos de procesos de Airflow CRM 2.0.

# 3.1. ❌ Fuentes de Datos Productivas

Solo se deben utilizar fuentes de datos gobernadas donde exista un equipo responsable
asociado.

# Lo que no se debe hacer:

Utilizar esquemas como:

- BCIMKT
- ARMVIEWS
- ARMWORK
- ARMOUT
- EDM_DMSEGTO_TB
- MKT_CRM_CMP_TB
- MKT_DESA_JOURNEYBUILDER_TB
- MKT_TMP_JOURNEYBUILDER_TB
- EDW_TEMPUSU
- DS_ARMWVIEWS
- DS_ARMOUT
- DS_ARMWORK
- DOM_BCI_STG_TB




DOM_BCI_DSR_TB
<page_header>DOM_BCI_DSR_VW</page_header>

Lo correcto:

- Utilizar esquemas productivos y gobernados como:

# 3.2. ⚠ SELECT a Vistas de Fuentes de Datos Productivas

Siempre se debería hacer consultas a Vistas dentro de la sentencia SELECT.

En caso de hacer consulta a una tabla, debiese ser exclusivamente porque no existe una vista asociada a esa tabla.

# 3.3. ⚠ Filtrado de Fuentes de Datos Productivas

Con el objetivo de optimizar la obtención de datos a trabajar, se recomienda filtrar las fuentes de datos productivas (tablas de entrada) entre periodos de tiempo definidos. Esto limita el procesamiento al periodo específico requerido, evitando así la manipulación del volumen total de la información.

Para saber en base a qué campo filtrar, se debe realizar un SHOW TABLE a la tabla original y ver en que campo está particionada la tabla.

En caso de que la tabla no se encuentre particionada, queda a criterio del desarrollador elegir el campo por el cual se debiese filtrar la información.

A continuación, se muestra un ejemplo de un SHOW TABLE para poder distinguir qué campo utilizar:



# CREATE MULTISET TABLE MKT_JOURNEYBUILDER_TBI_RMC_CRM_AUD

FALLBACK

NO BEFORE JOURNAL

NO AFTER JOURNAL

CHECKSUM = DEFAULT,

DEFAULT MERGEBLOCKRATIO.

MAP TD_MAP

| JD                  | INTEGER;                                           |
| ------------------- | -------------------------------------------------- |
| IT\_FECHA\_INICIO   | TIMESTAMP(S):                                      |
| IC\_AMBITO          | VARCHAR(SQ) CHARACTER SET LATIN NOT CASESPECIFIC;  |
| IC\_TIPO            | CHAR(I) CHARACTER SET LATIN NOT CASESPECIFIC,      |
| GATILLO             | CHAR(I) CHARACTER SET LATIN NOT CASESPECIFIC.      |
| PRODUCTO            | VARCHAR(4) CHARACTER SET LATIN NOT CASESPECIFIC.   |
| COMPORTAMIENTO      | VARCHAR(25) CHARACTER SET LATIN NOT CASESPECIFIC   |
| CANAL               | VARCHAR(TS) CHARACTER SET LATIN NOT CASESPECIFIC,  |
| INICIATIA           | VARCHAR(GD) CHARACTER SET LATIN NOT CASESPECIFIC,  |
| IE\_RUT             | INTEGER                                            |
| IC\_EMAIL           | VARCHAR(TDO) CHARACTER SET LATIN NOT CASESPECIFIC, |
| BANCA\_CLIENTE      | CHARO) CHARACTER SET LATIN NOT CASESPECIFIC;       |
| COD\_OFI            | CHAR(3) CHARACTER SET LATIN NOT CASESPECIFIC;      |
| IC\_ROL\_EJECUTIVO  | VARCHAR(35) CHARACTER SET LATIN NOT CASESPECIFIC;  |
| IC\_TIPO\_EJECUTIVO | VARCHAR(35) CHARACTER SET LATIN NOT CASESPECIFIC , |
| EJECUTIVO\_ASIGNADO | VARCHAR(IO) CHARACTER SET LATIN NOT CASESPECIFIC , |
| IE\_OFERTA          | INTEGER;                                           |
| GRUPO\_CONTROL      | INTEGER;                                           |
| IC\_CODIGO\_CANAL   | VARCHAR(?O) CHARACTER SET LATIN NOT CASESPECIFIC   |
| NOM\_ARCHIVO        | VARCHAR(2ED) CHARACTER SET LATIN NOT CASESPECIFIC, |
| IC\_RUN\_D          | VARCHAR(IZ) CHARACTER SET LATIN NOT CASESPECIFIC)  |

PRIMARY INDEX (IE_ID IC_TIPO IC_INICIATIVA ,IE_RUT

PARTITION BY RANGE_N(CAST(UT_FECHA_INICIO) AS DATE AT TIME ZONE INTERVAL '0 00' HOUR TO MINUTE BETWEEN DATE '2016-01-01' AND DATE '2030-01-31' EACH INTERVAL MONTH):

En este ejemplo, se debería utilizar el campo IT_Fecha_Inicio para filtrar.

# 3.4. ❌ Manejo de Fechas

No se debe utilizar CURRENT_DATE. En su lugar, se deben utilizar las variables de fechas de Airflow (por ejemplo: ds_nodash), pues no permite el reproceso a un periodo anterior.

Se permiten excepciones para guardar la fecha en la que se guarda el registro. Esto debe ser justificado.

# 3.5. ❌ Consultas Anidadas

Se recomienda evitar las consultas anidadas por razones de performance, en su lugar evaluar el abordar las consultas anidadas dentro de tablas temporales considerando la creación de índices por los campos llaves a utilizar en los JOIN a estas tablas, así como la recolección de estadísticas de los mismos.

# 3.6. ❌ Líneas de Código Comentadas

No pueden existir líneas de código comentadas. Toda query o línea de código que no se ejecuta, no debe incluirse en el script.

Lo que no se debe hacer:

1    SELECT
2     Te_Fecha_Ref
3     ,Te_Modelo_Id
4     ,Tc_Producto
5    FROM
6     EDW_TEMPUSU.T_CREA_VARIABLES_CON_PROB_CONTEO
7    WHERE
8     NOT(Tc_Producto=1)
9     --AND NOT(Tc_Producto=2)
10     AND  Te_Modelo_Id IN (2,3);






# Lo correcto:

1     SELECT
2       Te_Fecha_Ref
3       ,Te_Modelo_Id
4       ,Tc_Producto
5     FROM
6       EDW_TEMPUSU.T_CREA_VARIABLES_CON_PROB_CONTEO
7     WHERE
8       NOT(Tc_Producto=1)  AND Te_Modelo_Id IN  (2,3);

# 3.7

⚠ Uso de DISTINCT

Evite el uso de DISTINCT; utilice GROUP BY en su lugar.

# Lo que no se debe hacer:

1  SELECT DISTINCT A.RUT, A. FECHA_EJEC,
2  CASE WHEN E.BANCA LIKE '%BANCA EMPRESARIO%' THEN 'PYME' WHEN E.BANCA LIKE '%NACE%' THEN
'NACE' ELSE NULL END AS BANCA,
3  A.ID_GATILLO, B.PRODUCTO, B.AMBITO,  B.TIPO,  B.GATILLO,
4  CAST(B.PROBABILIDAD*B.SPREAD*B.DURATION*C.PESO*CAST(D.MONTO_COMERCIAL AS DECIMAL(30,2)) AS
BIGINT) SCORE,
5  E.TIPO_CLIENTE||' - '||E.NOMBRE_SEGMENTO ADICIONAL
6  ,'SYD' AS CANAL
7  FROM EDW_TEMPUSU.AE_CRM_PYME_GEN_CCOP8 A
8  LEFT JOIN BCIMKT.AE_CRM_PYME_PARAMETROS B  ON A.ID_GATILLO=B.ID_GATILLO
9  LEFT JOIN BCIMKT.AE_CRM_PYME_PESO_VALIDEZ C   ON A.ID_GATILLO=C.ID_GATILLO
10  LEFT JOIN BCIMKT.AE_CRM_PYME_RUTERO_ACT E  ON A.RUT=E.RU
11  LEFT JOIN BCIMKT.AE_CRM_PYME_MONTO D ON D.TRAMO_VENTAS_FINAL=E.TRAMO_VENTAS_FINAL

# Lo correcto:

1    SELECT
2     a.Td_Rut
3     ,a.Tf_Fecha_Ejec
4     ,CASE WHEN e.Sc_Banca  LIKE '%BANCA EMPRESARIO%'
5                THEN 'Pyme'
6          WHEN e.Sc_Banca   LIKE '%NACE%'
7                THEN 'Nace'
8                ELSE NULL
9     END  Tc_Banca
10     ,a.Tc_Id_Gatillo
11     ,b.Sc_Producto
12     ,b.Sc_Ambito
13     ,b.Sc_Tipo
14     ,b.Sc_Gatillo
15     ,CAST(b.Sd_Probabilidad*b.Sd_Spread*b.Se_Duration*c.Se_Peso*CAST(d.Monto_Consumo AS
DECIMAL(30,2)) AS BIGINT) AS Score
16     ,e.Sc_Tipo_Cliente||' - '||e.Sc_Nombre_Segmento AS Adicional
17     ,'SYD' AS  Canal
18    FROM






19     EDW_TEMPUSU.T_CRM_PYME_1A_GEN_CCOP8 a
20     LEFT JOIN MKT_CRM_ANALYTICS_TB.S_STG_EMP_1A_PARAMETROS b
21     ON  a.Tc_Id Gatillo=b.Sc_Id_Gatillo
22     LEFT JOIN MKT_CRM_ANALYTICS_TB.S_STG_EMP_1A_PESO_VALIDEZ c
23     ON  a.Tc_Id Gatillo=c.Sc_Id_Gatillo
24     LEFT JOIN MKT_CRM_ANALYTICS_TB.S_STG_EMP_1A_RUTERO_PYME e
25     ON  a.Td_Rut=e.Sd_Rut
26     LEFT JOIN MKT_CRM_ANALYTICS_TB.ae_crm_pyme_socios_monto d
27     ON  d.Tramo_Renta=e.Sc_Tramo_Ventas_Final
28    WHERE
29     e.Sc_Marca_Cliente_Bci = 'Pyme'
30    GROUP BY
31     a.Td_Rut
32     ,a.Tf_Fecha_Ejec
33     ,Tc_Banca
34     ,a.Tc_Id_Gatillo
35     ,b.Sc_Producto
36     ,b.Sc Ambito
37     ,b.Sc_Tipo
38     ,b.Sc_Gatillo
39     ,Score
40     ,Adicional;

# 3.8. ❌ Acerca de la Utilización de Tablas SET y MULTISET

Las tablas definidas como SET no permiten registros duplicados, mientras que las definidas como MULTISET si lo hacen. Si no se especifica en el DDL de creación de la tabla entonces Teradata creará la misma por defecto como SET.

Una tabla definida como SET fuerza al motor a realizar una validación de duplicidad de registros cada vez que se inserte o se actualice una fila en la tabla. Esto degrada la performance sobre todo sí necesitamos hacer inserciones masivas de registros.

Antes de crear una tabla es importante saber qué tipo de datos vamos a almacenar para elegir el mejor tipo de definición, siempre recordando que el tipo SET hace que el motor trabaje más para eliminar los duplicados:

- Si al insertar los registros se utiliza un GROUP BY o un QUALIFY entonces se recomienda utilizar el tipo MULTISET ya que estas sentencias ya habrán eliminado los duplicados.
- Si la tabla tiene un índice único (UPI) tampoco se justifica usar SET ya que el UPI no permitirá índices duplicados de por sí.

En resumen, para el desarrollo de procesos se recomienda evitar la utilización de tablas SET, ya que provocan una degradación del performance de la máquina Teradata. Este problema se





acentúa cuando los índices de las tablas están mal definidos provocando una mala distribución interna de los datos.

Para evitar este problema se recomienda siempre definir tablas MULTISET con índices acotados (en lo posible únicos).

# 3.9. Uso de las Cláusulas LEFT, RIGHT, FULL OUTER JOIN

# 3.9.1. ❌ Uso Excesivo

Se recomienda evitar el exceso de uso de la cláusula JOIN cuando se pretende obtener un resultado parcial.

Es decir, LEFT, RIGHT, o cuando se requiere un producto cruz, FULL OUTER, siendo este último el más pesado y, sí y sólo sí, puede ser utilizado para cruces mínimos que no hagan crecer los registros de forma exponencial. Esto además será revisado por parte del equipo de mantención de datos, quedando a su criterio si es aceptado o no.

Cuando sea imperativo el uso de muchos cruces de este tipo se recomienda separarla consultas más pequeñas utilizando tablas temporales de paso.

El límite de JOINS máximo permitido por consulta es de 7 JOINS.

# 3.9.2. ⚠ Orden de JOINS

A lo expuesto anteriormente y siempre pensando en la performance del proceso, en la utilización de la sintaxis JOIN (LEFT, RIGHT, OUTER, INNER), es obligatorio respetar el orden de los JOIN: de izquierda a derecha cuando es LEFT o de derecha a izquierda si es RIGHT cuando se realiza la comparación en el ON.

Lo que no se debe hacer:

1    SELECT
2     P.Party_Id
3     ,EIH.External_Identification_Num
4    FROM
5     edw_vw.party P
6     LEFT JOIN edw_vw.external_identification_hist EIH
7     ON   EIH.party_id =  P.party_id
8    WHERE
9     EIH.party_end_dt IS  NULL;

Lo correcto:




# 3.9.3. ❌ Cláusula ON

No se debe hacer transformación en la cláusula ON a los campos que vengan de fuentes como DW, con grandes volúmenes de datos. Si se necesita hacer una transformación de datos para igualar o comparar se debe hacer a tablas temporales que se crean en el script.

Esto se debe realizar por el costo enorme de procesamiento de formatear la tabla con más registros, en vez de hacerlo en la tabla más pequeña.

Existen dos prácticas para no realizar transformaciones dentro de la cláusula ON :

1. Realizar las transformaciones dentro de la cláusula SELECT.
2. Realizar las transformaciones en tablas temporales.

# Lo que no se debe hacer:

1    SELECT
2     A.Sd_Nro_Solicitud
3    FROM
4     MKT_CRM_ANALYTICS_TB.S_STG_EMP_1A_RUTERO_PYME A
5     INNER JOIN EDC_SUC_VW.SUC_ESTADO_SOLICITUD C
6     ON   CAST(A.Sd_Nro_Solicitud AS INTEGER) = C.Nro_Solicitud
7    ;

# Lo correcto:

La prioridad sería castear el campo de la tabla más pequeña y luego comparar. Otra opción es realizar la transformación en los campos del SELECT y utilizar el alias del campo en el ON, es decir:

1    SELECT
2     CAST(A.Sd_Nro_Solicitud AS INTEGER) AS Num_Solicitud
3    FROM
4     MKT_CRM_ANALYTICS_TB.S_STG_EMP_1A_RUTERO_PYME A
5     INNER JOIN EDC_SUC_VW.SUC_ESTADO_SOLICITUD C
6     ON   Num_Solicitud = C.Nro_Solicitud
7    ;





# 3.10. ❌ Cláusula WHERE

No se debe hacer transformación en la cláusula WHERE a los campos que vengan de fuentes como DW, con grandes volúmenes de datos. Si se necesita hacer una transformación de datos para igualar o comparar se debe hacer preferiblemente a las tablas temporales que se crean en el script.

Esto se debe realizar por el costo enorme de procesamiento de formatear la tabla con más registros, en vez de hacerlo en la tabla más pequeña.

Existen dos prácticas para no realizar transformaciones dentro del WHERE :

1. Realizar las transformaciones dentro de la cláusula SELECT.
2. Realizar las transformaciones en tablas temporales.

Lo que no se debe hacer:

1    SELECT
2     C.Fec_Asig_Sol
3    FROM
4     MKT_CRM_ANALYTICS_TB.S_STG_EMP_1A_RUTERO_PYME A
5     INNER JOIN EDC_SUC_VW.SUC_ESTADO_SOLICITUD C
6     ON   A.Sd_Nro_Solicitud = C.Nro_Solicitud
7    WHERE
8     CAST(C.Fec_Asig_Sol AS DATE FORMAT 'YYYY-MM-DD') = A.Sf_Fecha_Ejec - 2

Lo correcto:

La prioridad sería castear el campo de la tabla más pequeña y luego comparar. Otra opción es realizar la transformación en los campos del SELECT y utilizar el alias del campo en el WHERE, es decir:

1    SELECT
2     CAST(C.Fec_Asig_Sol AS DATE FORMAT 'YYYY-MM-DD') AS Fecha_Asig
3    FROM
4     MKT_CRM_ANALYTICS_TB.S_STG_EMP_1A_RUTERO_PYME A
5     INNER JOIN EDC_SUC_VW.SUC_ESTADO_SOLICITUD C
6     ON   A.Sd_Nro_Solicitud = C.Nro_Solicitud
7    WHERE
8     Fecha_Asig = A.Sf_Fecha_Ejec - 2
9    ;

# 3.11. ❌ Uso de Comparador ‘&#x3C;>ʼ

El uso del comparador &#x3C;> se debe sustituir por el NOT(campo1=campo2).

Lo que no se debe hacer:



1    SELECT
2     Te_Fecha_Ref
3     ,Te_Modelo_Id
4     ,Tc_Producto
5    FROM
6     EDW_TEMPUSU.T_CREA_VARIABLES_CON_PROB_CONTEO
7    WHERE
8     Tc_Producto &#x3C;> 3
9     AND  Tc_Producto &#x3C;> 2;

Lo correcto:

1    SELECT
2     Te_Fecha_Ref
3     ,Te_Modelo_Id
4     ,Tc_Producto
5    FROM
6     EDW_TEMPUSU.T_CREA_VARIABLES_CON_PROB_CONTEO
7    WHERE
8     NOT(Tc_Producto=3)
9     AND  NOT(Tc_Producto=2);

# 3.12. ⚠ Comando LIKE

Se recomienda no usar la sentencia LIKE en los procesos, ya que ocupa muchos recursos y
afecta de manera considerable la performance tanto del proceso como el de la máquina.

Lo que no se debe hacer:

1    SELECT
2    Account_Num
3    ,Account_Modifier_Num
4    FROM Edw_Vw.Agreement
5    WHERE Account_Num LIKE 'D%';

Lo correcto:

Esta instrucción en la mayoría de las veces puede ser reemplazada por las siguientes
instrucciones:

SUBSTR , la cual es más efectiva en la búsqueda de información.

POSITION , la cual valida si un STRING se encuentra en dentro de un determinado campo.

Aplicando SUBSTR :

1 SELECT



# 3.13. ❌ Comando IN

Debemos tener mucho cuidado cuando usemos esta sentencia, ya que al igual que el LIKE utilizan mucho recurso de máquina y afecta nuestros procesos cuando el universo de los datos es de gran magnitud.

Para evitar el uso de la sentencia IN, se sugiere crear una tabla temporal con los datos y con esto podemos realizar un INNER JOIN de manera más natural para la máquina.

El límite máximo de valores permitidos en un comando IN es de 10 valores, para casos de más valores se debe utilizar la estrategia de crear una tabla temporal con los datos.

Si la cantidad de valores es mayor a 100, se recomienda utilizar FASTLOAD para poder insertar los datos a la tabla temporal.

En el siguiente ejemplo sólo mostramos una búsqueda por 5 datos, se debe considerar la recomendación para mayor volumen de información.

# Lo que no se debe hacer:

1    SELECT
2     Event_Id
3     ,Acct_Num_Relates
4     ,Event_Start_Date
5    FROM
6     Edw_Vw.Event_Tdm
7    WHERE
8     Acct_Num_Relates IN
('000000000001','000000000002','000000000003','000000000004','000000000005');

# Lo correcto:

Esta query para que tenga un mejor rendimiento, se debe reemplazar por las sentencias:

1    SELECT
2    Account_Num
3    ,Account_Modifier_Num
4    FROM Edw_Vw.Agreement a
5    WHERE SUBSTR(Account_Num, 1, 1) = 'D';

1    SELECT
2    Account_Num
3    ,Razon_Social
4    FROM EDW_TEMPUSU.Temporal1
5    WHERE POSITION('restaurant' IN  Razon_Social) > 0;






# 1

Se crea tabla temporal para insertar valores del IN

DROP TABLE edw_temp.event_ope;

CREATE MULTISET  TABLE edw_temp.event_ope
(
Acct_Num_Relates CHAR(12) CHARACTER   SET LATIN NOT CASESPECIFIC
)
UNIQUE PRIMARY INDEX (Acct_Num_Relates);

Insertamos los valores dentro de la tabla temporal

INSERT into edw_temp.event_ope  VALUES ('000000000001');
INSERT into edw_temp.event_ope  VALUES ('000000000002');
INSERT into edw_temp.event_ope  VALUES ('000000000003');
INSERT into edw_temp.event_ope  VALUES ('000000000004');
INSERT into edw_temp.event_ope  VALUES ('000000000005');

COLLECT STATISTICS INDEX (Acct_Num_Relates) ON edw_temp.event_ope;

Finalmente realizamos la consulta

SELECT
Event_Id
,Acct_Num_Relates
,Event_Start_Date
FROM
Edw_Vw.Event_Tdm e
,edw_temp.event_ope o
WHERE
e.Acct_Num_Relates = o.Acct_Num_Relates;

# 3.14. ⚠ Comando OR

Al igual que la sentencia IN, la sentencia OR tiene un uso excesivo de máquina ya que obliga al motor a realizar un FULL TABLE SCAN.

Se recomienda utilizar sentencias OR cuando estas son validaciones simples, si son complejas se debería subdividir la consulta.

Lo que no se debe hacer:

SELECT
Account_Num
,Account_Modifier_Num
FROM
Edw_Vw.Agreement A
WHERE
(A.Account_Num  = 'D03799991404' AND A.Account_Num = 'D12899953101')
OR (A.Account_Num = 'D12899953100' AND   A.Account_Num = 'D03799991405');

Lo correcto:

SELECT





SELECT
Account_Num,
Account_Modifier_Num
FROM
Edw_Vw.Agreement A
WHERE
A.Account_Num = 'D03799991404'
AND  A.Account_Num = 'D12899953101'
UNION ALL
SELECT
Account_Num,
Account_Modifier_Num
FROM
Edw_Vw.Agreement A
WHERE
A.Account_Num = 'D12899953100'
AND  A.Account_Num = 'D03799991405';

# 3.15. ⚠ Comando EXISTS/NOT EXISTS

El uso de los comandos EXISTS (y NOT EXISTS) quedará excluido de las sentencias que se podrán utilizar dentro de cualquier script (query) Teradata en primera instancia, dado que presenta problemas en la versión actual del motor de base de datos. Sin embargo, no se prohíbe completamente su uso previa revisión de performance, y si no hubiese una mejor solución, por parte del equipo de mantención de datos.

# 3.16. ❌ Sentencias CASE

El límite de sentencias CASE que puede tener una consulta es de máximo 7 usos por consulta. No obstante, se debe considerar que su uso requiere de Spool, por lo cual se debería realizar una subdivisión de la consulta generada si se necesitan utilizar más sentencias CASE.

*Dentro de las sentencias CASE está permitido utilizar los comandos que suelen estar prohibidos dentro de la normativa, tales como: OR, IN, LIKE, entre otros.

# 3.17. ⚠ Sentencias REPEAT

El uso de la sentencia REPEAT se limita a la inserción de poca volumetría de registros (por ejemplo al insertar "periodos" sobre una tabla).

No se recomienda su uso sobre grandes volúmenes de información por la falta de recolección de estadísticas entre las inserciones de grupos de registros.

# 3.18. ❌ Sentencias UPDATE

La sentencia UPDATE está prohibida de usarse, pues su performance degrada el motor. En su lugar, se debe utilizar el método de aislar los registros que serán modificados. Es decir, crear





# 3.19. ❌ Tablas Volátiles

Está prohibido el uso de tablas Volátiles en los procesos por la pérdida de trazabilidad que implica su uso. En cualquier caso, se deben utilizar tablas temporales de paso que deben ser eliminadas una vez finalice el proceso.

# 3.20. ❌ Procedimientos Almacenados

Está prohibida la utilización de Procedimientos Almacenados (SP) en los procesos debido a la pérdida de trazabilidad que esto genera.

# 3.21. ⚠ Uso de Particiones en las Tablas

Se autoriza la implementación de tablas particionadas en Teradata. Se sugiere adoptar la estrategia de partición por rango de fechas para fragmentar la información en estructuras de menor tamaño y complejidad.

Se recomienda el uso de particiones en las tablas para las tablas históricas que se crean en el proceso.

Un método efectivo consiste en particionar la tabla mensualmente, lo que permite seleccionar únicamente los períodos de interés, en lugar de procesar la totalidad de los datos de la tabla cuando se realiza un SELECT.

A continuación, se muestra el ejemplo de una tabla particionada:

CREATE MULTISET TABLE MKT_JOURNEYBUILDER_TB.SEGUIMIENTO_IS_USER_IMPRESSION_BORRAR FALLBACK
NO BEFORE JOURNAL
NO AFTER JOURNAL
CHECKSUM DEFAULT,
DEFAULT MERGEBLOCKRATIO
MAP TD_MAPI
user_id VARCHAR(200) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL
experience_id VARCHAR(256) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL
event_ts TIMESTAMP(G) FORMAT 'YYYY-MM-DDbHHMISS'
user_group CHAR(1) CHARACTER SET LATIN NOT CASESPECIFIC NOT NULL COMPRESS ('C', 'D')
browser VARCHAR(256) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('other', 'chrome', 'safari', 'firefox', 'ie')
device VARCHAR(256) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('mobile', 'computer', 'other', 'tablet')
engagement VARCHAR(256) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('high', 'medium', 'low')
has_purchased VARCHAR(5) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('False', 'True')
impression_count SMALLINT
anonymous VARCHAR(5) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('False', 'True')
first_time VARCHAR(5) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('False', 'True')
os VARCHAR(256) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('android', 'ios', 'other', 'windows', 'x', 'linux')
platform VARCHAR(256) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('web', 'mobile_app')
source VARCHAR(256) CHARACTER SET LATIN NOT CASESPECIFIC COMPRESS ('1', '4', '52')
dw_created_ts TIMESTAMP(6) FORMAT 'MM-DDbHHMLSS'
PRIMARY INDEX (user_id, experience_id, event_ts)
PARTITION BY RANGE_N(event_ts BETWEEN TIMESTAMP '2022-01-01 00:00:00.000000+00:00' AND TIMESTAMP '2025-12-31 23:59:59.999999+00:00' EACH INTERVAL MONTH);

Dentro del PARTITION BY se debe utilizar la función RANGE_N y se deben definir los siguientes parámetros:

El campo donde particionar (ej: event_ts)





El tiempo por el cual se particionará la tabla (ej: BETWEEN TIMESTAMP '2022-01-01 00:00:00.000000+00:00' AND TIMESTAMP '2025-12-31 23:59:59.999999+00:00')

Los intervalos de partición de la tabla (ej: EACH INTERVAL '1' MONTH)

# 3.22. ❌ Acerca del Spool

El tamaño estándar del Spool en ambiente productivo de Teradata está fijado en base a la experiencia y uso que históricamente ha tenido. Se ha comprobado que los procesos que requieren de un uso mayor de Spool generalmente tienen problemas de otra índole:

- Exceso de LEFT JOINs en una misma consulta
- Mala distribución de los datos (mal índice primario)
- etc.

Si el problema es por la gran cantidad de cruces o trabajo en una misma consulta, se recomienda atomizar las mismas bajo la metodología de creación de tablas temporales para evitar cualquier problema con el Spool.


